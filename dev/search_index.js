var documenterSearchIndex = {"docs":
[{"location":"#Time-Zones-1","page":"Introduction","title":"Time Zones","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"TimeZones.jl provides access to the IANA time zone database (also referred to as the tz database) to the programming language Julia. This library can handle any time zone in the tz database but some have excluded by default due to them being deemed as historical (such as \"Etc/*\").","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The TimeZones package extends the Dates module provided by Julia version 0.4. In order to use this package you will need to have Julia 0.4 or higher installed on your system. Details on downloading and installing Julia can be found on the language homepage.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Once Julia is installed you can simply install TimeZones using the package manager. First open a Julia interactive session and run:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"julia> using Pkg  # on Julia 0.7+\n\njulia> Pkg.add(\"TimeZones\")","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This command will install the latest version of TimeZones, automatically download the latest tz database, and convert the data into an Julia optimized format.","category":"page"},{"location":"types/#Time-Zone-Types-1","page":"Types","title":"Time Zone Types","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"DocTestSetup = quote\n    using TimeZones, Dates\nend","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"using TimeZones, Dates","category":"page"},{"location":"types/#TimeZone-1","page":"Types","title":"TimeZone","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"A TimeZone is an abstract type that represents information regarding a specific time zone. Typically you will create an instance of a TimeZone by passing in a zone name to the convenience constructor TimeZone:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> TimeZone(\"Europe/Warsaw\")\nEurope/Warsaw (UTC+1/UTC+2)","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"You can also create a TimeZone by using a tz string macro:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> tz\"Europe/Warsaw\"\nEurope/Warsaw (UTC+1/UTC+2)","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"To see all of the currently available time zone names:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"timezone_names()\nnothing; # hide","category":"page"},{"location":"types/#ZonedDateTime-1","page":"Types","title":"ZonedDateTime","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"A ZonedDateTime is a time zone aware version of a DateTime (in Python parlance). Note that all ZonedDateTime instances will always be in the correct zone without requiring manual normalization (unlike Python's pytz module).","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"To construct a ZonedDateTime instance you just need a DateTime and a TimeZone:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> ZonedDateTime(DateTime(2014, 1, 1), tz\"Europe/Warsaw\")\n2014-01-01T00:00:00+01:00\n\njulia> ZonedDateTime(2014, 1, 1, tz\"Europe/Warsaw\")\n2014-01-01T00:00:00+01:00","category":"page"},{"location":"types/#VariableTimeZone-1","page":"Types","title":"VariableTimeZone","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"A VariableTimeZone is a concrete type that is a subtype of TimeZone that has offsets that change depending on the specified time. We've already seen an example of a VariableTimeZone: \"Europe/Warsaw\"","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> warsaw = tz\"Europe/Warsaw\"\nEurope/Warsaw (UTC+1/UTC+2)\n\njulia> typeof(warsaw)\nVariableTimeZone\n\njulia> ZonedDateTime(DateTime(2014, 1, 1), warsaw)\n2014-01-01T00:00:00+01:00\n\njulia> ZonedDateTime(DateTime(2014, 6, 1), warsaw)\n2014-06-01T00:00:00+02:00","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"From the above example you can see that the offset for this time zone differed based upon the DateTime provided. An unfortunate side effect of having the offset change over time results in some difficulties in working with dates near the transitions. For example when working with a DateTime that occurs during the \"spring forward\" transition will result in a NonExistentTimeError:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> ZonedDateTime(DateTime(2014, 3, 30, 1), warsaw)\n2014-03-30T01:00:00+01:00\n\njulia> ZonedDateTime(DateTime(2014, 3, 30, 2), warsaw)\nERROR: NonExistentTimeError: Local DateTime 2014-03-30T02:00:00 does not exist within Europe/Warsaw\n\njulia> ZonedDateTime(DateTime(2014, 3, 30, 3), warsaw)\n2014-03-30T03:00:00+02:00","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Alternatively, working with a DateTime that occurs during the \"fall back\" transition results in a AmbiguousTimeError. Providing additional parameters can deal with the ambiguity:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> dt = DateTime(2014,10,26,2)\n2014-10-26T02:00:00\n\njulia> ZonedDateTime(dt, warsaw)\nERROR: AmbiguousTimeError: Local DateTime 2014-10-26T02:00:00 is ambiguous within Europe/Warsaw\n\njulia> ZonedDateTime(dt, warsaw, 1)  # first occurrence of the duplicate hour\n2014-10-26T02:00:00+02:00\n\njulia> ZonedDateTime(dt, warsaw, 2)  # second occurrence of the duplicate hour\n2014-10-26T02:00:00+01:00\n\njulia> ZonedDateTime(dt, warsaw, true)  # use the hour which is in daylight saving time\n2014-10-26T02:00:00+02:00\n\njulia> ZonedDateTime(dt, warsaw, false)  # use the hour which is not in daylight saving time\n2014-10-26T02:00:00+01:00","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"When working with dates prior to the year 1900 you may notice that the time zone offset includes minutes or even seconds. These kind of offsets are normal:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> ZonedDateTime(1879, 1, 1, warsaw)\n1879-01-01T00:00:00+01:24","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Alternatively, when using future dates past the year 2038 will result in an error:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> ZonedDateTime(2039, warsaw)\nERROR: UnhandledTimeError: TimeZone Europe/Warsaw does not handle dates on or after 2038-03-28T01:00:00 UTC","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"It is possible to have timezones that work beyond 2038 but it since these dates are in the future it is possible the timezone rules may change and will not be accurate.","category":"page"},{"location":"types/#FixedTimeZone-1","page":"Types","title":"FixedTimeZone","text":"","category":"section"},{"location":"types/#","page":"Types","title":"Types","text":"A FixedTimeZone is a concrete type that is a subtype of TimeZone that has a single offset for all of time. An example of this kind of time zone is: \"UTC\"","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> typeof(TimeZone(\"UTC\"))\nFixedTimeZone","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Unlike a VariableTimeZone there are no issues with offsets changing over time because with a FixedTimeZone the offset never changes. If you need a FixedTimeZone that is not provided by the tz database you can manually construct one:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"FixedTimeZone(\"UTC+6\")\nFixedTimeZone(\"-0800\")\nFixedTimeZone(\"-04:30\")\nFixedTimeZone(\"+12:34:56\")\nFixedTimeZone(\"FOO\", -6 * 3600)  # 6 hours in seconds\nnothing; # hide","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"Constructing a ZonedDateTime works similarly to VariableTimeZone:","category":"page"},{"location":"types/#","page":"Types","title":"Types","text":"julia> ZonedDateTime(1960, 1, 1, tz\"UTC\")\n1960-01-01T00:00:00+00:00","category":"page"},{"location":"conversions/#Conversions-1","page":"Converting","title":"Conversions","text":"","category":"section"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"DocTestSetup = quote\n    using TimeZones, Dates\nend","category":"page"},{"location":"conversions/#Converting-Date/Time-without-time-zone-information-1","page":"Converting","title":"Converting Date/Time without time zone information","text":"","category":"section"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"To convert from a ZonedDateTime into a vanilla DateTime, one can use the DateTime constructor. Just passing in the ZonedDateTime will directly drop the time zone, and passing in UTC as the second argument will extract the time as UTC instead. Note: The canonical way to represent datetimes is generally in UTC, as this is a requirement to correctly compute the Unix Timestamp.","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"julia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> DateTime(zdt)\n2014-05-30T21:00:00\n\njulia> DateTime(zdt, UTC)\n2014-05-31T01:00:00","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Similar can be done for Date and Time:","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"julia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> Date(zdt)\n2014-05-30\n\njulia> Date(zdt, UTC)\n2014-05-31\n\njulia> Time(zdt)\n21:00:00\n\njulia> Time(zdt, UTC)\n01:00:00","category":"page"},{"location":"conversions/#Switching-Time-Zones-1","page":"Converting","title":"Switching Time Zones","text":"","category":"section"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Switching an existing ZonedDateTime from one TimeZone to another can be done with the function astimezone:","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"julia> zdt = ZonedDateTime(2014, 1, 1, tz\"UTC\")\n2014-01-01T00:00:00+00:00\n\njulia> astimezone(zdt, tz\"Asia/Tokyo\")\n2014-01-01T09:00:00+09:00","category":"page"},{"location":"conversions/#Parsing-strings-1","page":"Converting","title":"Parsing strings","text":"","category":"section"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"ZonedDateTime parsing extends the functionality provided by Dates. If you haven't already it is recommended that you first read the official Julia manual on Date and DateTime. The TimeZones package adds z and Z to the list of available parsing character codes:","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Code Matches Comment\nz +04:00, +0400, UTC+4 Matches a numeric UTC offset\nZ Asia/Dubai, UTC Matches names of time zones from the TZ database","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Note that with the exception of \"UTC\" and \"GMT\" time zone abbrevations cannot be parsed using the Z character code since most abbreviations are ambiguous. For example abbreviation \"MST\" could be interpreted as \"Mountain Standard Time\" (UTC-7) or \"Moscow Summer Time\" (UTC+3:31).","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Parsing a ZonedDateTime just requires the text to parse and a format string:","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"julia> ZonedDateTime(\"20150101-0700\", \"yyyymmddzzzz\")\n2015-01-01T00:00:00-07:00\n\njulia> ZonedDateTime(\"2015-08-06T22:25:31+07:00\", \"yyyy-mm-ddTHH:MM:SSzzzz\")\n2015-08-06T22:25:31+07:00","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"When parsing several ZonedDateTime strings which use the same format you will see better performance if you first create a Dates.DateFormat instead of passing in a raw format string.","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"julia> df = Dates.DateFormat(\"yy-mm-ddz\");\n\njulia> ZonedDateTime(\"2015-03-29+01:00\", df)\n2015-03-29T00:00:00+01:00\n\njulia> ZonedDateTime(\"2015-03-30+02:00\", df)\n2015-03-30T00:00:00+02:00","category":"page"},{"location":"conversions/#Formatting-strings-1","page":"Converting","title":"Formatting strings","text":"","category":"section"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Formatting a ZonedDateTime as a string also extends the functionality provided by Base.Dates. The TimeZones package adds the new formatting character codes z and Z to the list of available formatting character codes:","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Code Examples Comment\nz +04:00 Numeric UTC offset\nZ GST, UTC Time zone abbreviation","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"It is recommended that you prefer the use of the z character code over Z time zone abbreviations can be interpreted in different ways.","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"Formatting uses the Dates.format function with a ZonedDateTime and a format string:","category":"page"},{"location":"conversions/#","page":"Converting","title":"Converting","text":"julia> zdt = ZonedDateTime(2015, 8, 6, 22, 25, tz\"Europe/Warsaw\")\n2015-08-06T22:25:00+02:00\n\njulia> Dates.format(zdt, \"yyyymmddzzzz\")\n\"20150806+02:00\"\n\njulia> Dates.format(zdt, \"yyyy-mm-dd HH:MM ZZZ\")\n\"2015-08-06 22:25 CEST\"","category":"page"},{"location":"arithmetic/#Arithmetic-1","page":"Arithmetic","title":"Arithmetic","text":"","category":"section"},{"location":"arithmetic/#ZonedDateTime-Period-Arithmetic-1","page":"Arithmetic","title":"ZonedDateTime-Period Arithmetic","text":"","category":"section"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"ZonedDateTime uses calendrical arithmetic in a similar manner to DateTime but with some key differences. Lets look at these differences by adding a day to March 30th 2014 in Europe/Warsaw.","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"julia> using TimeZones, Dates\n\njulia> warsaw = tz\"Europe/Warsaw\"\nEurope/Warsaw (UTC+1/UTC+2)\n\njulia> spring = ZonedDateTime(2014, 3, 30, warsaw)\n2014-03-30T00:00:00+01:00\n\njulia> spring + Day(1)\n2014-03-31T00:00:00+02:00","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"Adding a day to the ZonedDateTime changed the date from the 30th to the 31st as expected. Looking closely however you'll notice that the time zone offset changed from +01:00 to +02:00. The reason for this change is because the time zone \"Europe/Warsaw\" switched from standard time (+01:00) to daylight saving time (+02:00) on the 30th. The change in the offset caused the local DateTime 2014-03-31T02:00:00 to be skipped effectively making the 30th a day which only contained 23 hours. Alternatively if we added hours we can see the difference:","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"julia> spring + Hour(24)\n2014-03-31T01:00:00+02:00\n\njulia> spring + Hour(23)\n2014-03-31T00:00:00+02:00","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"A potential cause of confusion regarding this behaviour is the loss in associativity when ordering is forced. For example:","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"julia> (spring + Day(1)) + Hour(24)\n2014-04-01T00:00:00+02:00\n\njulia> (spring + Hour(24)) + Day(1)\n2014-04-01T01:00:00+02:00","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"The first example adds 1 day to 2014-03-30T00:00:00+01:00, which results in 2014-03-31T00:00:00+02:00; then we add 24 hours to get 2014-04-01T00:00:00+02:00. The second example add 24 hours first to get 2014-03-31T01:00:00+02:00, and then add 1 day which results in 2014-04-01T01:00:00+02:00. When working with operations using multiple periods the operations will be ordered by the Period's types and not their positional order; this means Day will be added before Hour. Hence the following does result in associativity:","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"julia> spring + Hour(24) + Day(1)\n2014-04-01T00:00:00+02:00\n\njulia> spring + Day(1) + Hour(24)\n2014-04-01T00:00:00+02:00","category":"page"},{"location":"arithmetic/#Ranges-1","page":"Arithmetic","title":"Ranges","text":"","category":"section"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"Query and adjuster functions can be used as with Date and DateTime. We can use filter to apply a predicate to a StepRange of TimeTypes to produce a vector of dates that fit certain inclusion criteria (for example, \"every fifth Wednesday of the month in 2014 at 09:00\"):","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"julia> warsaw = tz\"Europe/Warsaw\"\nEurope/Warsaw (UTC+1/UTC+2)\n\njulia> start = ZonedDateTime(2014, warsaw)\n2014-01-01T00:00:00+01:00\n\njulia> stop = ZonedDateTime(2015, warsaw)\n2015-01-01T00:00:00+01:00\n\njulia> filter(start:Dates.Hour(1):stop) do d\n           Dates.dayofweek(d) == Dates.Wednesday &&\n           Dates.hour(d) == 9 &&\n           Dates.dayofweekofmonth(d) == 5\n       end\n5-element Array{ZonedDateTime,1}:\n 2014-01-29T09:00:00+01:00\n 2014-04-30T09:00:00+02:00\n 2014-07-30T09:00:00+02:00\n 2014-10-29T09:00:00+01:00\n 2014-12-31T09:00:00+01:00","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"Note the transition from standard time to daylight saving time (and back again).","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"It is possible to define a range start:step:stop such that start and stop have different time zones. In this case the resulting ZonedDateTimes will all share a time zone with start but the range will stop at the instant that corresponds to stop in start's time zone. For example:","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"julia> start = ZonedDateTime(2016, 1, 1, 12, tz\"UTC\")\n2016-01-01T12:00:00+00:00\n\njulia> stop = ZonedDateTime(2016, 1, 1, 18, tz\"Europe/Warsaw\")\n2016-01-01T18:00:00+01:00\n\njulia> collect(start:Dates.Hour(1):stop)\n6-element Array{ZonedDateTime,1}:\n 2016-01-01T12:00:00+00:00\n 2016-01-01T13:00:00+00:00\n 2016-01-01T14:00:00+00:00\n 2016-01-01T15:00:00+00:00\n 2016-01-01T16:00:00+00:00\n 2016-01-01T17:00:00+00:00","category":"page"},{"location":"arithmetic/#","page":"Arithmetic","title":"Arithmetic","text":"Note that 2016-01-01T17:00:00 in UTC corresponds to 2016-01-01T18:00:00 in \"Europe/Warsaw\", which is the requested endpoint of the range.","category":"page"},{"location":"rounding/#Rounding-a-ZonedDateTime-1","page":"Rounding","title":"Rounding a ZonedDateTime","text":"","category":"section"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"DocTestSetup = quote\n    using TimeZones, Dates\nend","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"Rounding operations (floor, ceil, and round) on ZonedDateTimes are performed in a similar manner to DateTime and should generally behave as expected. When VariableTimeZone transitions are involved, however, unexpected behaviour may be encountered.","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"Instead of performing rounding operations on a UTC representation of the ZonedDateTime, which would in some cases be computationally less expensive, rounding is done in the local time zone. This ensures that rounding behaves as expected and is maximally meaningful.","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"If rounding were done in UTC, consider how rounding to the nearest day would be resolved for non-UTC time zones: the result would be 00:00 UTC, which wouldn't be midnight local time. Similarly, when rounding to the nearest hour in Australia/Eucla (UTC+08:45), the result wouldn't be on the hour in the local time zone.","category":"page"},{"location":"rounding/#Rounding-to-a-TimePeriod-1","page":"Rounding","title":"Rounding to a TimePeriod","text":"","category":"section"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"When the target resolution is a TimePeriod the likelihood of encountering an ambiguous or non-existent time (due to daylight saving time transitions) is increased. To resolve this issue, rounding a ZonedDateTime with a VariableTimeZone to a TimePeriod uses the DateTime value in the appropriate FixedTimeZone, then reconverts it to a ZonedDateTime in the appropriate VariableTimeZone afterward. (See Examples below.)","category":"page"},{"location":"rounding/#Rounding-to-a-DatePeriod-1","page":"Rounding","title":"Rounding to a DatePeriod","text":"","category":"section"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"When the target resolution is a DatePeriod rounding is done in the local time zone in a straightforward fashion.","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"Rounding is not an entirely \"safe\" operation for ZonedDateTimes, as in some cases historical transitions for some time zones (Asia/Colombo, for example) occur at midnight. In such cases rounding to a DatePeriod may still result in an AmbiguousTimeError or a NonExistentTimeErrors. (But such occurrences should be relatively rare.)","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"Regular daylight saving time transitions should be safe.","category":"page"},{"location":"rounding/#Examples-1","page":"Rounding","title":"Examples","text":"","category":"section"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"The America/Winnipeg time zone transitioned from Central Standard Time (UTC-6:00) to Central Daylight Time (UTC-5:00) on 2016-03-13, moving directly from 01:59:59 to 03:00:00.","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"julia> zdt = ZonedDateTime(2016, 3, 13, 1, 45, tz\"America/Winnipeg\")\n2016-03-13T01:45:00-06:00\n\njulia> floor(zdt, Dates.Day)\n2016-03-13T00:00:00-06:00\n\njulia> ceil(zdt, Dates.Day)\n2016-03-14T00:00:00-05:00\n\njulia> round(zdt, Dates.Day)\n2016-03-13T00:00:00-06:00\n\njulia> floor(zdt, Dates.Hour)\n2016-03-13T01:00:00-06:00\n\njulia> ceil(zdt, Dates.Hour)\n2016-03-13T03:00:00-05:00\n\njulia> round(zdt, Dates.Hour)\n2016-03-13T03:00:00-05:00","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"The Asia/Colombo time zone revised the definition of Lanka Time from UTC+6:30 to UTC+6:00 on 1996-10-26, moving from 00:29:59 back to 00:00:00.","category":"page"},{"location":"rounding/#","page":"Rounding","title":"Rounding","text":"julia> zdt = ZonedDateTime(1996, 10, 25, 23, 45, tz\"Asia/Colombo\")\n1996-10-25T23:45:00+06:30\n\njulia> round(zdt, Dates.Hour)\n1996-10-26T00:00:00+06:30\n\njulia> round(zdt, Dates.Day)\nERROR: AmbiguousTimeError: Local DateTime 1996-10-26T00:00:00 is ambiguous within Asia/Colombo","category":"page"},{"location":"current/#Current-Time-1","page":"Current Time","title":"Current Time","text":"","category":"section"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"using TimeZones\nusing Dates","category":"page"},{"location":"current/#now-/-System-Time-Zone-1","page":"Current Time","title":"now / System Time Zone","text":"","category":"section"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"Julia provides the now() method to retrieve your current system's time as a DateTime. The TimeZones.jl package provides an additional now(::TimeZone) method providing the current time as a ZonedDateTime:","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"now(tz\"Europe/Warsaw\")\nnothing; # hide","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"To get the TimeZone currently specified on you system you can use localzone(). Combining this method with the new now method produces the current system time in the current system's time zone:","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"now(localzone())\nnothing; # hide","category":"page"},{"location":"current/#today-1","page":"Current Time","title":"today","text":"","category":"section"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"Similar to now the TimeZones package also provides a today(::TimeZone) method which allows you to determine the current date as a Date in the specified TimeZone.","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"a, b = now(tz\"Pacific/Midway\"), now(tz\"Pacific/Apia\")\na - b\ntoday(tz\"Pacific/Midway\"), today(tz\"Pacific/Apia\")","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"You should be careful not to use today() when working with ZonedDateTimes as you may end up using the wrong day. For example:","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"midway, apia = tz\"Pacific/Midway\", tz\"Pacific/Apia\"\nZonedDateTime(today() + Time(11), midway)\nZonedDateTime(today() + Time(11), apia)  # Wrong date; with the current rules apia should be one day ahead of midway\nZonedDateTime(today(midway) + Time(11), midway)\nZonedDateTime(today(apia) + Time(11), apia)","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"Alternatively, you can use the todayat function which takes care of this for you:","category":"page"},{"location":"current/#","page":"Current Time","title":"Current Time","text":"todayat(Time(11), tz\"Pacific/Midway\")\ntodayat(Time(11), tz\"Pacific/Apia\")","category":"page"},{"location":"faq/#Frequently-Asked-Questions-1","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"DocTestSetup = quote\n    using TimeZones\nend","category":"page"},{"location":"faq/#etc_tzs-1","page":"Frequently Asked Questions","title":"Where are the \"Etc/*\" time zones?","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"According to IANA the \"Etc/*\" time zones are only included in the tz database for \"historical reasons\". Furthermore the time zones offsets provided the Etc/GMT±HH can be misleading. For example the Etc/GMT+4 time zone is 4 hours behind UTC rather than 4 hours ahead as most people expect. Since TimeZones.jl already provides an easy way of constructing fixed offset time zones using FixedTimeZone it was decided to only allow users to create these time zones if they explicitly ask for them.","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> TimeZone(\"Etc/GMT+4\")\nERROR: ArgumentError: The time zone \"Etc/GMT+4\" is of class `TimeZones.Class(:LEGACY)` which is currently not allowed by the mask: `TimeZones.Class(:FIXED) | TimeZones.Class(:STANDARD)`\n\njulia> TimeZone(\"Etc/GMT+4\", TimeZones.Class(:LEGACY))\nEtc/GMT+4 (UTC-4)","category":"page"},{"location":"faq/#future_tzs-1","page":"Frequently Asked Questions","title":"Far-future ZonedDateTime with VariableTimeZone","text":"","category":"section"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Due to the internal representation of a VariableTimeZone it is infeasible to determine a time zones transitions to infinity. Since 2038-01-19T03:14:07 is the last DateTime that can be represented by an Int32 (Dates.unix2datetime(typemax(Int32))) it was decided that 2037 would be the last year in which all transition dates are computed. If additional transitions are known to exist after the last transition then a cutoff date is specified.","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> warsaw = tz\"Europe/Warsaw\"\nEurope/Warsaw (UTC+1/UTC+2)\n\njulia> last(warsaw.transitions)\n2037-10-25T01:00:00 UTC+1/+0 (CET)\n\njulia> warsaw.cutoff  # DateTime up until the last transition is effective\n2038-03-28T01:00:00\n\njulia> ZonedDateTime(DateTime(2039), warsaw)\nERROR: UnhandledTimeError: TimeZone Europe/Warsaw does not handle dates on or after 2038-03-28T01:00:00 UTC","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"It is important to note that since we are taking about future time zone transitions and the rules dictating these transitions are subject to change and may not be accurate. If you still want to work with future ZonedDateTime past the default cutoff you can re-compile the TimeZone objects and specify the max_year keyword:","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> using TimeZones\n\njulia> TimeZones.TZData.compile(max_year=2200)\n\njulia> ZonedDateTime(DateTime(2100), tz\"Europe/Warsaw\")\n2100-01-01T00:00:00+01:00","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Warning: since the tz string macro loads the TimeZone at compile time the time zone will be loaded before the tz data is recompiled. You can avoid this problem by using the TimeZone constructor.","category":"page"},{"location":"faq/#","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"julia> begin\n           TimeZones.TZData.compile(max_year=2210)\n           ZonedDateTime(DateTime(2205), tz\"Europe/Warsaw\")\n       end\nERROR: UnhandledTimeError: TimeZone Europe/Warsaw does not handle dates on or after 2038-03-28T01:00:00 UTC\n\njulia> begin\n           TimeZones.TZData.compile(max_year=2220)\n           ZonedDateTime(DateTime(2215), TimeZone(\"Europe/Warsaw\"))\n       end\n2215-01-01T00:00:00+01:00","category":"page"},{"location":"api-public/#TimeZones-Public-API-1","page":"API – Public","title":"TimeZones Public API","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"DocTestSetup = quote\n    using TimeZones\nend","category":"page"},{"location":"api-public/#TimeZone-1","page":"API – Public","title":"TimeZone","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"TimeZone(::AbstractString)\n@tz_str\nlocalzone\nFixedTimeZone\nVariableTimeZone\nTimeZones.build","category":"page"},{"location":"api-public/#Dates.TimeZone-Tuple{AbstractString}","page":"API – Public","title":"Dates.TimeZone","text":"TimeZone(str::AbstractString) -> TimeZone\n\nConstructs a TimeZone subtype based upon the string. If the string is a recognized standard time zone name then data is loaded from the compiled IANA time zone database. Otherwise the string is parsed as a fixed time zone.\n\nA list of recognized standard and legacy time zones names can is available by running timezone_names(). Supported fixed time zone string formats can be found in docstring for FixedTimeZone(::AbstractString).\n\nExamples\n\njulia> TimeZone(\"Europe/Warsaw\")\nEurope/Warsaw (UTC+1/UTC+2)\n\njulia> TimeZone(\"UTC\")\nUTC\n\n\n\n\n\n","category":"method"},{"location":"api-public/#TimeZones.@tz_str","page":"API – Public","title":"TimeZones.@tz_str","text":"@tz_str -> TimeZone\n\nConstructs a TimeZone subtype based upon the string at parse time. See docstring of TimeZone for more details.\n\njulia> tz\"Africa/Nairobi\"\nAfrica/Nairobi (UTC+3)\n\n\n\n\n\n","category":"macro"},{"location":"api-public/#TimeZones.localzone","page":"API – Public","title":"TimeZones.localzone","text":"localzone() -> TimeZone\n\nReturns a TimeZone object that is equivalent to the system's current time zone.\n\n\n\n\n\n","category":"function"},{"location":"api-public/#TimeZones.FixedTimeZone","page":"API – Public","title":"TimeZones.FixedTimeZone","text":"FixedTimeZone\n\nA TimeZone with a constant offset for all of time.\n\n\n\n\n\n","category":"type"},{"location":"api-public/#TimeZones.VariableTimeZone","page":"API – Public","title":"TimeZones.VariableTimeZone","text":"VariableTimeZone\n\nA TimeZone with an offset that changes over time.\n\n\n\n\n\n","category":"type"},{"location":"api-public/#TimeZones.build","page":"API – Public","title":"TimeZones.build","text":"build(version=\"2020a\"; force=false) -> Nothing\n\nBuilds the TimeZones package with the specified tzdata version and regions. The version is typically a 4-digit year followed by a lowercase ASCII letter (e.g. \"2020a\"). The force flag is used to re-download tzdata archives.\n\n\n\n\n\n","category":"function"},{"location":"api-public/#Legacy-Time-Zones-1","page":"API – Public","title":"Legacy Time Zones","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"TimeZone(::AbstractString, ::TimeZones.Class)\nTimeZones.Class\nistimezone","category":"page"},{"location":"api-public/#Dates.TimeZone-Tuple{AbstractString,TimeZones.Class}","page":"API – Public","title":"Dates.TimeZone","text":"TimeZone(str::AbstractString, mask::Class) -> TimeZone\n\nSimilar to TimeZone(::AbstractString) but allows you to control what time zone classes are allowed to be constructed with mask. Can be used to construct time zones which are classified as \"legacy\".\n\nExamples\n\njulia> TimeZone(\"US/Pacific\")\nERROR: ArgumentError: The time zone \"US/Pacific\" is of class `TimeZones.Class(:LEGACY)` which is currently not allowed by the mask: `TimeZones.Class(:FIXED) | TimeZones.Class(:STANDARD)`\n\njulia> TimeZone(\"US/Pacific\", TimeZones.Class(:LEGACY))\nUS/Pacific (UTC-8/UTC-7)\n\n\n\n\n\n","category":"method"},{"location":"api-public/#TimeZones.Class","page":"API – Public","title":"TimeZones.Class","text":"Class\n\nA type used for controlling which classes of TimeZone are considered valid. Instances of Class can be combined using bitwise operators to generate a mask which allows multiple classes to be considered valid at once.\n\nCurrently supported masks are:\n\nClass(:FIXED): Class indicating the time zone name is parsable as a fixed UTC offset.\nClass(:STANDARD): The time zone name is included in the primary IANA tz source files.\nClass(:LEGACY): The time zone name is included in the deprecated IANA tz source files.\nClass(:NONE): Mask that will match nothing.\nClass(:DEFAULT): Default mask used by functions: Class(:FIXED) | Class(:STANDARD)\nClass(:ALL): Mask allowing all supported classes.\n\n\n\n\n\n","category":"type"},{"location":"api-public/#TimeZones.istimezone","page":"API – Public","title":"TimeZones.istimezone","text":"istimezone(str::AbstractString, mask::Class=Class(:DEFAULT)) -> Bool\n\nCheck whether a string is a valid for constructing a TimeZone with the provided mask.\n\n\n\n\n\n","category":"function"},{"location":"api-public/#ZonedDateTime-1","page":"API – Public","title":"ZonedDateTime","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"ZonedDateTime\nZonedDateTime(::DateTime, ::VariableTimeZone)\nZonedDateTime(::DateTime, ::VariableTimeZone, ::Integer)\nZonedDateTime(::DateTime, ::VariableTimeZone, ::Bool)\nastimezone\nTimeZones.timezone(::ZonedDateTime)\nDateTime(::ZonedDateTime)\nDateTime(::ZonedDateTime, ::Type{UTC})\nDate(::ZonedDateTime)\nDate(::ZonedDateTime, ::Type{UTC})\nTime(::ZonedDateTime)\nTime(::ZonedDateTime, ::Type{UTC})","category":"page"},{"location":"api-public/#TimeZones.ZonedDateTime","page":"API – Public","title":"TimeZones.ZonedDateTime","text":"ZonedDateTime(y, [m, d, h, mi, s, ms], tz, [amb]) -> DateTime\n\nConstruct a ZonedDateTime type by parts. Arguments y, m, ..., ms must be convertible to Int64 and tz must be a TimeZone. If the given DateTime is ambiguous in the given TimeZone then amb can be supplied to resolve ambiguity.\n\n\n\n\n\n","category":"type"},{"location":"api-public/#TimeZones.ZonedDateTime-Tuple{DateTime,VariableTimeZone}","page":"API – Public","title":"TimeZones.ZonedDateTime","text":"ZonedDateTime(dt::DateTime, tz::TimeZone; from_utc=false) -> ZonedDateTime\n\nConstruct a ZonedDateTime by applying a TimeZone to a DateTime. When the from_utc keyword is true the given DateTime is assumed to be in UTC instead of in local time and is converted to the specified TimeZone.  Note that when from_utc is true the given DateTime will always exists and is never ambiguous.\n\n\n\n\n\n","category":"method"},{"location":"api-public/#TimeZones.ZonedDateTime-Tuple{DateTime,VariableTimeZone,Integer}","page":"API – Public","title":"TimeZones.ZonedDateTime","text":"ZonedDateTime(dt::DateTime, tz::VariableTimeZone, occurrence::Integer) -> ZonedDateTime\n\nConstruct a ZonedDateTime by applying a TimeZone to a DateTime. If the DateTime is ambiguous within the given time zone you can set occurrence to a positive integer to resolve the ambiguity.\n\n\n\n\n\n","category":"method"},{"location":"api-public/#TimeZones.ZonedDateTime-Tuple{DateTime,VariableTimeZone,Bool}","page":"API – Public","title":"TimeZones.ZonedDateTime","text":"ZonedDateTime(dt::DateTime, tz::VariableTimeZone, is_dst::Bool) -> ZonedDateTime\n\nConstruct a ZonedDateTime by applying a TimeZone to a DateTime. If the DateTime is ambiguous within the given time zone you can set is_dst to resolve the ambiguity.\n\n\n\n\n\n","category":"method"},{"location":"api-public/#TimeZones.astimezone","page":"API – Public","title":"TimeZones.astimezone","text":"astimezone(zdt::ZonedDateTime, tz::TimeZone) -> ZonedDateTime\n\nConverts a ZonedDateTime from its current TimeZone into the specified TimeZone.\n\n\n\n\n\n","category":"function"},{"location":"api-public/#TimeZones.timezone-Tuple{ZonedDateTime}","page":"API – Public","title":"TimeZones.timezone","text":"timezone(::ZonedDateTime) -> TimeZone\n\nReturns the TimeZone used by the ZonedDateTime.\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Dates.DateTime-Tuple{ZonedDateTime}","page":"API – Public","title":"Dates.DateTime","text":"DateTime(zdt::ZonedDateTime) -> DateTime\n\nCreate a DateTime by dropping the associated time zone. Effectively, this new DateTime is implicitly associated with timezone(zdt).\n\nExample\n\njulia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> DateTime(zdt)\n2014-05-30T21:00:00\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Dates.DateTime-Tuple{ZonedDateTime,Type{UTC}}","page":"API – Public","title":"Dates.DateTime","text":"DateTime(zdt::ZonedDateTime, ::Type{UTC}) -> DateTime\n\nCreate a DateTime which is implicitly associated with UTC.\n\nExample\n\njulia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> DateTime(zdt, UTC)\n2014-05-31T01:00:00\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Dates.Date-Tuple{ZonedDateTime}","page":"API – Public","title":"Dates.Date","text":"Date(zdt::ZonedDateTime) -> Date\n\nCreate a Date by dropping the associated time zone. Effectively, this new Date is implicitly associated with timezone(zdt).\n\nExample\n\njulia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> Date(zdt)\n2014-05-30\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Dates.Date-Tuple{ZonedDateTime,Type{UTC}}","page":"API – Public","title":"Dates.Date","text":"Date(zdt::ZonedDateTime, ::Type{UTC}) -> Date\n\nCreate a Date which is implicitly associated with UTC.\n\nExample\n\njulia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> Date(zdt, UTC)\n2014-05-31\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Dates.Time-Tuple{ZonedDateTime}","page":"API – Public","title":"Dates.Time","text":"Time(zdt::ZonedDateTime) -> Time\n\nCreate a Time by dropping the associated time zone. Effectively, this new Time is implicitly associated with timezone(zdt).\n\nExample\n\njulia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> Time(zdt)\n21:00:00\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Dates.Time-Tuple{ZonedDateTime,Type{UTC}}","page":"API – Public","title":"Dates.Time","text":"Time(zdt::ZonedDateTime, ::Type{UTC}) -> Date\n\nCreate a Time which is implicitly associated with UTC.\n\nExample\n\njulia> zdt = ZonedDateTime(2014, 5, 30, 21, tz\"UTC-4\")\n2014-05-30T21:00:00-04:00\n\njulia> Time(zdt, UTC)\n01:00:00\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Current-Time-1","page":"API – Public","title":"Current Time","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"now(::TimeZone)\ntoday(::TimeZone)\ntodayat","category":"page"},{"location":"api-public/#Dates.now-Tuple{TimeZone}","page":"API – Public","title":"Dates.now","text":"now(::TimeZone) -> ZonedDateTime\n\nReturns a ZonedDateTime corresponding to the user's system time in the specified TimeZone.\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Dates.today-Tuple{TimeZone}","page":"API – Public","title":"Dates.today","text":"today(tz::TimeZone) -> Date\n\nReturns the date portion of now(tz) in local time.\n\nExamples\n\njulia> a, b = now(tz\"Pacific/Midway\"), now(tz\"Pacific/Apia\")\n(2017-11-09T03:47:04.226-11:00, 2017-11-10T04:47:04.226+14:00)\n\njulia> a - b\n0 milliseconds\n\njulia> today(tz\"Pacific/Midway\"), today(tz\"Pacific/Apia\")\n(2017-11-09, 2017-11-10)\n\n\n\n\n\n","category":"method"},{"location":"api-public/#TimeZones.todayat","page":"API – Public","title":"TimeZones.todayat","text":"todayat(tod::Time, tz::TimeZone, [amb]) -> ZonedDateTime\n\nCreates a ZonedDateTime for today at the specified time of day. If the result is ambiguous in the given TimeZone then amb can be supplied to resolve ambiguity.\n\nExamples\n\njulia> today(tz\"Europe/Warsaw\")\n2017-11-09\n\njulia> todayat(Time(10, 30), tz\"Europe/Warsaw\")\n2017-11-09T10:30:00+01:00\n\n\n\n\n\n","category":"function"},{"location":"api-public/#Rounding-1","page":"API – Public","title":"Rounding","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"round(::ZonedDateTime, ::Period)\nfloor(::ZonedDateTime, ::Period)\nceil(::ZonedDateTime, ::Period)","category":"page"},{"location":"api-public/#Base.round-Tuple{ZonedDateTime,Period}","page":"API – Public","title":"Base.round","text":"round(zdt::ZonedDateTime, p::Period, [r::RoundingMode]) -> ZonedDateTime\nround(zdt::ZonedDateTime, p::Type{Period}, [r::RoundingMode]) -> ZonedDateTime\n\nReturns the ZonedDateTime nearest to zdt at resolution p. The result will be in the same time zone as zdt. By default (RoundNearestTiesUp), ties (e.g., rounding 9:30 to the nearest hour) will be rounded up.\n\nFor convenience, p may be a type instead of a value: round(zdt, Dates.Hour) is a shortcut for round(zdt, Dates.Hour(1)).\n\nValid rounding modes for round(::TimeType, ::Period, ::RoundingMode) are RoundNearestTiesUp (default), RoundDown (floor), and RoundUp (ceil).\n\nVariableTimeZone Transitions\n\nInstead of performing rounding operations on the ZonedDateTime's internal UTC DateTime, which would be computationally less expensive, rounding is done in the local time zone. This ensures that rounding behaves as expected and is maximally meaningful.\n\nIf rounding were done in UTC, consider how rounding to the nearest day would be resolved for non-UTC time zones: the result would be 00:00 UTC, which wouldn't be midnight local time. Similarly, when rounding to the nearest hour in Australia/Eucla (UTC+08:45), the result wouldn't be on the hour in the local time zone.\n\nWhen p is a DatePeriod rounding is done in the local time zone in a straightforward fashion. When p is a TimePeriod the likelihood of encountering an ambiguous or non-existent time (due to daylight saving time transitions) is increased. To resolve this issue, rounding a ZonedDateTime with a VariableTimeZone to a TimePeriod uses the DateTime value in the appropriate FixedTimeZone, then reconverts it to a ZonedDateTime in the appropriate VariableTimeZone afterward.\n\nRounding is not an entirely \"safe\" operation for ZonedDateTimes, as in some cases historical transitions for some time zones (such as Asia/Colombo) occur at midnight. In such cases rounding to a DatePeriod may still result in an AmbiguousTimeError or a NonExistentTimeError. (But these events should be relatively rare.)\n\nRegular daylight saving time transitions should be safe.\n\nExamples\n\nThe America/Winnipeg time zone transitioned from Central Standard Time (UTC-6:00) to Central Daylight Time (UTC-5:00) on 2016-03-13, moving directly from 01:59:59 to 03:00:00.\n\njulia> zdt = ZonedDateTime(2016, 3, 13, 1, 45, TimeZone(\"America/Winnipeg\"))\n2016-03-13T01:45:00-06:00\n\njulia> round(zdt, Dates.Hour)\n2016-03-13T03:00:00-05:00\n\njulia> round(zdt, Dates.Day)\n2016-03-13T00:00:00-06:00\n\nThe Asia/Colombo time zone revised the definition of Lanka Time from UTC+6:30 to UTC+6:00 on 1996-10-26, moving from 00:29:59 back to 00:00:00.\n\njulia> zdt = ZonedDateTime(1996, 10, 25, 23, 45, TimeZone(\"Asia/Colombo\"))\n1996-10-25T23:45:00+06:30\n\njulia> round(zdt, Dates.Hour)\n1996-10-26T00:00:00+06:30\n\njulia> round(zdt, Dates.Day)\nERROR: Local DateTime 1996-10-26T00:00:00 is ambiguous\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Base.floor-Tuple{ZonedDateTime,Period}","page":"API – Public","title":"Base.floor","text":"floor(zdt::ZonedDateTime, p::Period) -> ZonedDateTime\nfloor(zdt::ZonedDateTime, p::Type{Period}) -> ZonedDateTime\n\nReturns the nearest ZonedDateTime less than or equal to zdt at resolution p. The result will be in the same time zone as zdt.\n\nFor convenience, p may be a type instead of a value: floor(zdt, Dates.Hour) is a shortcut for floor(zdt, Dates.Hour(1)).\n\nVariableTimeZone transitions are handled as for round.\n\nExamples\n\nThe America/Winnipeg time zone transitioned from Central Standard Time (UTC-6:00) to Central Daylight Time (UTC-5:00) on 2016-03-13, moving directly from 01:59:59 to 03:00:00.\n\njulia> zdt = ZonedDateTime(2016, 3, 13, 1, 45, TimeZone(\"America/Winnipeg\"))\n2016-03-13T01:45:00-06:00\n\njulia> floor(zdt, Dates.Day)\n2016-03-13T00:00:00-06:00\n\njulia> floor(zdt, Dates.Hour)\n2016-03-13T01:00:00-06:00\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Base.ceil-Tuple{ZonedDateTime,Period}","page":"API – Public","title":"Base.ceil","text":"ceil(zdt::ZonedDateTime, p::Period) -> ZonedDateTime\nceil(zdt::ZonedDateTime, p::Type{Period}) -> ZonedDateTime\n\nReturns the nearest ZonedDateTime greater than or equal to zdt at resolution p. The result will be in the same time zone as zdt.\n\nFor convenience, p may be a type instead of a value: ceil(zdt, Dates.Hour) is a shortcut for ceil(zdt, Dates.Hour(1)).\n\nVariableTimeZone transitions are handled as for round.\n\nExamples\n\nThe America/Winnipeg time zone transitioned from Central Standard Time (UTC-6:00) to Central Daylight Time (UTC-5:00) on 2016-03-13, moving directly from 01:59:59 to 03:00:00.\n\njulia> zdt = ZonedDateTime(2016, 3, 13, 1, 45, TimeZone(\"America/Winnipeg\"))\n2016-03-13T01:45:00-06:00\n\njulia> ceil(zdt, Dates.Day)\n2016-03-14T00:00:00-05:00\n\njulia> ceil(zdt, Dates.Hour)\n2016-03-13T03:00:00-05:00\n\n\n\n\n\n","category":"method"},{"location":"api-public/#Exceptions-1","page":"API – Public","title":"Exceptions","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"NonExistentTimeError\nAmbiguousTimeError\nUnhandledTimeError","category":"page"},{"location":"api-public/#TimeZones.NonExistentTimeError","page":"API – Public","title":"TimeZones.NonExistentTimeError","text":"NonExistentTimeError(local_datetime, timezone)\n\nThe provided local datetime is does not exist within the specified timezone. Typically occurs on daylight saving time transitions which \"spring forward\" causing an hour long period to be skipped.\n\n\n\n\n\n","category":"type"},{"location":"api-public/#TimeZones.AmbiguousTimeError","page":"API – Public","title":"TimeZones.AmbiguousTimeError","text":"AmbiguousTimeError(local_datetime, timezone)\n\nThe provided local datetime is ambiguous within the specified timezone. Typically occurs on daylight saving time transitions which \"fall back\" causing duplicate hour long period.\n\n\n\n\n\n","category":"type"},{"location":"api-public/#TimeZones.UnhandledTimeError","page":"API – Public","title":"TimeZones.UnhandledTimeError","text":"UnhandledTimeError(timezone)\n\nThe timezone calculation occurs beyond the last calculated transition.\n\n\n\n\n\n","category":"type"},{"location":"api-public/#Discovery-1","page":"API – Public","title":"Discovery","text":"","category":"section"},{"location":"api-public/#","page":"API – Public","title":"API – Public","text":"timezone_names\nall_timezones\ntimezones_from_abbr\ntimezone_abbrs\nnext_transition_instant\nshow_next_transition","category":"page"},{"location":"api-public/#TimeZones.timezone_names","page":"API – Public","title":"TimeZones.timezone_names","text":"timezone_names() -> Vector{String}\n\nReturns a sorted list of all of the pre-computed time zone names.\n\n\n\n\n\n","category":"function"},{"location":"api-public/#TimeZones.all_timezones","page":"API – Public","title":"TimeZones.all_timezones","text":"all_timezones() -> Vector{TimeZone}\n\nReturns all pre-computed TimeZones.\n\n\n\n\n\nall_timezones(criteria::Function) -> Vector{TimeZone}\n\nReturns TimeZones that match the given criteria function. The criteria function takes two parameters: UTC transition (DateTime) and transition zone (FixedTimeZone).\n\nExamples\n\nFind all time zones which contain an absolute UTC offset greater than 15 hours:\n\nall_timezones() do dt, zone\n    abs(zone.offset.std) > Dates.Second(Dates.Hour(15))\nend\n\nDetermine all time zones which have a non-hourly daylight saving time offset:\n\nall_timezones() do dt, zone\n    zone.offset.dst % Dates.Second(Dates.Hour(1)) != 0\nend\n\n\n\n\n\n","category":"function"},{"location":"api-public/#TimeZones.timezones_from_abbr","page":"API – Public","title":"TimeZones.timezones_from_abbr","text":"timezones_from_abbr(abbr) -> Vector{TimeZone}\n\nReturns all TimeZones that have the specified abbrevation\n\n\n\n\n\n","category":"function"},{"location":"api-public/#TimeZones.timezone_abbrs","page":"API – Public","title":"TimeZones.timezone_abbrs","text":"timezone_abbrs -> Vector{String}\n\nReturns a sorted list of all pre-computed time zone abbrevations.\n\n\n\n\n\n","category":"function"},{"location":"api-public/#TimeZones.next_transition_instant","page":"API – Public","title":"TimeZones.next_transition_instant","text":"next_transition_instant(zdt::ZonedDateTime) -> Union{ZonedDateTime, Nothing}\nnext_transition_instant(tz::TimeZone=localzone()) -> Union{ZonedDateTime, Nothing}\n\nDetermine the next instant at which a time zone transition occurs (typically due to daylight-savings time). If no there exists no future transition then nothing will be returned.\n\nNote that the provided ZonedDateTime isn't normally constructable:\n\njulia> instant = next_transition_instant(ZonedDateTime(2018, 3, 1, tz\"Europe/London\"))\n2018-03-25T01:00:00+00:00\n\njulia> instant - Millisecond(1)  # Instant prior to the change\n2018-03-25T00:59:59.999+00:00\n\njulia> instant - Millisecond(0)  # Instant after the change\n2018-03-25T02:00:00+01:00\n\njulia> ZonedDateTime(2018, 3, 25, 1, tz\"Europe/London\")  # Cannot normally construct the `instant`\nERROR: NonExistentTimeError: Local DateTime 2018-03-25T01:00:00 does not exist within Europe/London\n...\n\n\n\n\n\n","category":"function"},{"location":"api-public/#TimeZones.show_next_transition","page":"API – Public","title":"TimeZones.show_next_transition","text":"show_next_transition(io::IO=stdout, zdt::ZonedDateTime)\nshow_next_transition(io::IO=stdout, tz::TimeZone=localzone())\n\nDisplay useful information about the next time zone transition (typically due to daylight-savings time). Information displayed includes:\n\nTransition Date: the local date at which the transition occurs (2018-10-28)\nLocal Time Change: the way the local clock with change (02:00 falls back to 01:00) and   the direction of the change (\"Forward\" or \"Backward\")\nOffset Change: the standard offset and DST offset that occurs before and after the  transition\nTransition From: the instant before the transition occurs\nTransition To: the instant after the transition occurs\n\njulia> show_next_transition(ZonedDateTime(2018, 8, 1, tz\"Europe/London\"))\nTransition Date:   2018-10-28\nLocal Time Change: 02:00 → 01:00 (Backward)\nOffset Change:     UTC+0/+1 → UTC+0/+0\nTransition From:   2018-10-28T01:59:59.999+01:00 (BST)\nTransition To:     2018-10-28T01:00:00.000+00:00 (GMT)\n\njulia> show_next_transition(ZonedDateTime(2011, 12, 1, tz\"Pacific/Apia\"))\nTransition Date:   2011-12-30\nLocal Time Change: 00:00 → 00:00 (Forward)\nOffset Change:     UTC-11/+1 → UTC+13/+1\nTransition From:   2011-12-29T23:59:59.999-10:00\nTransition To:     2011-12-31T00:00:00.000+14:00\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones-Internal-API-1","page":"API – Private","title":"TimeZones Internal API","text":"","category":"section"},{"location":"api-private/#","page":"API – Private","title":"API – Private","text":"DocTestSetup = quote\n    using TimeZones\nend","category":"page"},{"location":"api-private/#TZData-1","page":"API – Private","title":"TZData","text":"","category":"section"},{"location":"api-private/#","page":"API – Private","title":"API – Private","text":"TimeZones.TZData.tzdata_url\nTimeZones.TZData.tzdata_download\nTimeZones.TZData.isarchive\nTimeZones.TZData.readarchive\nTimeZones.TZData.extract\nTimeZones.TZData.tzdata_version_dir\nTimeZones.TZData.tzdata_version_archive\nTimeZones.TZData.read_news\nTimeZones.TZData.compile!\nTimeZones.TZData.tryparse_dayofmonth_function\nTimeZones.TZData.order_rules","category":"page"},{"location":"api-private/#TimeZones.TZData.tzdata_url","page":"API – Private","title":"TimeZones.TZData.tzdata_url","text":"tzdata_url(version=\"latest\") -> AbstractString\n\nGenerates a HTTPS URL for the specified tzdata version. Typical version strings are formatted as 4-digit year followed by a lowercase ASCII letter. Available versions start with \"tzdata\" and are listed on \"https://data.iana.org/time-zones/releases/\" or \"ftp://ftp.iana.org/tz/releases/\".\n\nExamples\n\njulia> tzdata_url(\"2017a\")\n\"https://data.iana.org/time-zones/releases/tzdata2017a.tar.gz\"\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.tzdata_download","page":"API – Private","title":"TimeZones.TZData.tzdata_download","text":"tzdata_download(version=\"latest\", dir=tempdir()) -> AbstractString\n\nDownloads a tzdata archive from IANA using the specified version to the specified directory. See tzdata_url for details on tzdata version strings.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.isarchive","page":"API – Private","title":"TimeZones.TZData.isarchive","text":"isarchive(path) -> Bool\n\nDetermines if the given path is an archive.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.readarchive","page":"API – Private","title":"TimeZones.TZData.readarchive","text":"readarchive(archive) -> Vector{AbstractString}\n\nReturns the file names contained in the archive.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.extract","page":"API – Private","title":"TimeZones.TZData.extract","text":"extract(archive, directory, [files]; [verbose=false]) -> Nothing\n\nExtracts files from a compressed tar archive to the specified directory. If files is specified only the files given will be extracted. The verbose flag can be used to display additional information to STDOUT.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.tzdata_version_dir","page":"API – Private","title":"TimeZones.TZData.tzdata_version_dir","text":"tzdata_version_dir(dir::AbstractString) -> AbstractString\n\nDetermines the tzdata version by inspecting various files in a directory.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.tzdata_version_archive","page":"API – Private","title":"TimeZones.TZData.tzdata_version_archive","text":"tzdata_version_archive(archive::AbstractString) -> AbstractString\n\nDetermines the tzdata version by inspecting the contents within the archive. Useful when downloading the latest archive \"tzdata-latest.tar.gz\".\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.read_news","page":"API – Private","title":"TimeZones.TZData.read_news","text":"read_news(news, [limit]) -> Vector{AbstractString}\n\nReads all of the tzdata versions from the NEWS file in the order in which they appear. Note that since the NEWS file is in reverse chronological order the versions will also be in that order. Useful for identifying the version of the tzdata.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.compile!","page":"API – Private","title":"TimeZones.TZData.compile!","text":"Resolves a named zone into TimeZone. Updates ordered with any new rules that were required to be ordered.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.tryparse_dayofmonth_function","page":"API – Private","title":"TimeZones.TZData.tryparse_dayofmonth_function","text":"tryparse_dayofmonth_function(str::AbstractString) -> Union{Function,Nothing}\n\nParse the various day-of-month formats used within tzdata source files. Returns a function which generates a Date observing the rule. The function returned (f) can be called by providing a year and month arguments or a Date (e.g. f(year, month) or f(::Date)).\n\njulia> f = tryparse_dayofmonth_function(\"lastSun\")\nlast_sunday_of_month (generic function with 1 method)\n\njulia> f(2019, 3)\n2019-03-31\n\njulia> f = tryparse_dayofmonth_function(\"Sun>=8\")\n#16 (generic function with 1 method)\n\njulia> f(2019, 3)\n2019-03-10\n\njulia> f = tryparse_dayofmonth_function(\"Fri<=1\")\n#16 (generic function with 1 method)\n\njulia> f(2019, 4)\n2019-03-29\n\njulia> f = tryparse_dayofmonth_function(\"15\")\n#18 (generic function with 1 method)\n\njulia> f(2019, 3)\n2019-03-15\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.TZData.order_rules","page":"API – Private","title":"TimeZones.TZData.order_rules","text":"Rules are typically ordered by the \"from\" than \"in\" fields. Since rules also contain a \"to\" field the written ordering can be problematic for resolving time zone transitions.\n\nExample:\n\n# Rule  NAME    FROM    TO  TYPE    IN  ON  AT      SAVE    LETTER/S\nRule    Poland  1918    1919    -   Sep 16  2:00s   0       -\nRule    Poland  1919    only    -   Apr 15  2:00s   1:00    S\nRule    Poland  1944    only    -   Apr  3  2:00s   1:00    S\n\nA simplistic way of iterating through the rules by years could yield the rules\nin the wrong order:\n\n# ON         AT      SAVE    LETTER/S\n1918-09-16   2:00s   0       -\n1919-09-16   2:00s   0       -\n1919-04-15   2:00s   1:00    S\n1944-04-03   2:00s   1:00    S\n\nThe order_rules function will expand the rules such that they can be ordered by the\n\"on\" date which ensures we process the rules in the correct order:\n\n1918-09-16   2:00s   0       -\n1919-04-15   2:00s   1:00    S\n1919-09-16   2:00s   0       -\n1944-04-03   2:00s   1:00    S\n\n\n\n\n\n","category":"function"},{"location":"api-private/#Interpretation-1","page":"API – Private","title":"Interpretation","text":"","category":"section"},{"location":"api-private/#","page":"API – Private","title":"API – Private","text":"TimeZones.transition_range\nTimeZones.interpret\nTimeZones.shift_gap\nTimeZones.first_valid\nTimeZones.last_valid","category":"page"},{"location":"api-private/#TimeZones.transition_range","page":"API – Private","title":"TimeZones.transition_range","text":"transition_range(dt::DateTime, tz::VariableTimeZone, context::Type{Union{Local,UTC}}) -> UnitRange\n\nFinds the indexes of the tz transitions which may be applicable for the dt. The given DateTime is expected to be local to the time zone or in UTC as specified by context. Note that UTC context will always return a range of length one.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.interpret","page":"API – Private","title":"TimeZones.interpret","text":"interpret(dt::DateTime, tz::VariableTimeZone, context::Type{Union{Local,UTC}}) -> Array{ZonedDateTime}\n\nProduces a list of possible ZonedDateTimes given a DateTime and VariableTimeZone. The result will be returned in chronological order. Note that DateTimes in the local context typically return 0-2 results while the UTC context will always return 1 result.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.shift_gap","page":"API – Private","title":"TimeZones.shift_gap","text":"shift_gap(local_dt::DateTime, tz::VariableTimeZone) -> Tuple\n\nGiven a non-existent local DateTime in a TimeZone produces a tuple containing two valid ZonedDateTimes that span the gap. Providing a valid local DateTime returns an empty tuple. Note that this function does not support passing in a UTC DateTime since there are no non-existent UTC DateTimes.\n\nAside: the function name refers to a period of invalid local time (gap) caused by daylight saving time or offset changes (shift).\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.first_valid","page":"API – Private","title":"TimeZones.first_valid","text":"first_valid(local_dt::DateTime, tz::VariableTimeZone, step::Period)\n\nConstruct a valid ZonedDateTime by adjusting the local DateTime. If the local DateTime is non-existent then it will be adjusted using the step to be after the gap. When the local DateTime is ambiguous the first ambiguous DateTime will be returned.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.last_valid","page":"API – Private","title":"TimeZones.last_valid","text":"last_valid(local_dt::DateTime, tz::VariableTimeZone, step::Period)\n\nConstruct a valid ZonedDateTime by adjusting the local DateTime. If the local DateTime is non-existent then it will be adjusted using the step to be before the gap. When the local DateTime is ambiguous the last ambiguous DateTime will be returned.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#Etc.-1","page":"API – Private","title":"Etc.","text":"","category":"section"},{"location":"api-private/#","page":"API – Private","title":"API – Private","text":"TimeZones.UTCOffset\nTimeZones.@optional\nTimeZones.read_tzfile\nTimeZones.parse_tz_format\nTimeZones.tryparse_tz_format\nhash(::ZonedDateTime, ::UInt)\nDates.guess(::ZonedDateTime, ::ZonedDateTime, ::Any)","category":"page"},{"location":"api-private/#TimeZones.UTCOffset","page":"API – Private","title":"TimeZones.UTCOffset","text":"UTCOffset\n\nA UTCOffset is an amount of time subtracted from or added to UTC to get the current local time – whether it's standard time or daylight saving time.\n\n\n\n\n\n","category":"type"},{"location":"api-private/#TimeZones.@optional","page":"API – Private","title":"TimeZones.@optional","text":"@optional(expr)\n\nCreates multiple method signatures to allow optional arguments before required arguments. For example:\n\nf(a=1, b=2, c) = ...\n\nbecomes:\n\nf(a, b, c) = ...\nf(a, c) = f(a, 2, c)\nf(c) = f(1, 2, c)\n\n\n\n\n\n","category":"macro"},{"location":"api-private/#TimeZones.read_tzfile","page":"API – Private","title":"TimeZones.read_tzfile","text":"read_tzfile(io::IO, name::AbstractString) -> TimeZone\n\nRead the content of an I/O stream and process it as a POSIX tzfile. The returned TimeZone will be given the supplied name name unless a FixedTimeZone is returned.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.parse_tz_format","page":"API – Private","title":"TimeZones.parse_tz_format","text":"parse_tz_format(str) -> TimeZone\n\nParse the time zone format typically provided via the \"TZ\" environment variable. Details on the format can be found under the man page for tzset.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#TimeZones.tryparse_tz_format","page":"API – Private","title":"TimeZones.tryparse_tz_format","text":"tryparse_tz_format(str) -> Union{TimeZone, Nothing}\n\nLike parse_tz_format, but returns either a value of the TimeZone, or nothing if the string does not contain a valid format.\n\n\n\n\n\n","category":"function"},{"location":"api-private/#Base.hash-Tuple{ZonedDateTime,UInt64}","page":"API – Private","title":"Base.hash","text":"hash(::ZonedDateTime, h)\n\nCompute an integer hash code for a ZonedDateTime by hashing the utc_datetime field. hash(:utc_instant, h) is used to avoid collisions with DateTime hashes.\n\n\n\n\n\n","category":"method"},{"location":"api-private/#Dates.guess-Tuple{ZonedDateTime,ZonedDateTime,Any}","page":"API – Private","title":"Dates.guess","text":"guess(start::ZonedDateTime, finish::ZonedDateTime, step) -> Integer\n\nGiven a start and end date, indicates how many steps/periods are between them. Defining this function allows StepRanges to be defined for ZonedDateTimes.\n\n\n\n\n\n","category":"method"}]
}
